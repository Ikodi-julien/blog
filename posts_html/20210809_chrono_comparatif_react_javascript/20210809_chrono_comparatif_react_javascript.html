<article>
  <h1>Un Chrono - Comparatif Javascript / React+Redux - + bonus async/await</h1>
  <ul class="post-metas">
    <li>Author:julien</li>
    <li>Published: 9 aoÃ»t 2021</li>
    <li>Category: JavaScript</li>
    <li>DurÃ©e lecture: 15mn</li>
  </ul>

  <p class="post-short">
    <em
      >Actuellement en pleine refonte du projet Â« Chronofit Â» avec React+Redux,
      une app dâ€™enchainement dâ€™intervals chronomÃ©trÃ©s destinÃ©e aux sportifs
      (enfin surtout pour moiâ€¦) initialement en PHP + VanillaJS, jâ€™ai du refaire
      la logique algorythmique du chrono.</em
    >
  </p>

  <p>
    Lâ€™objectif ici est de faire un comparatif rapide entre les deux solutions
    mises en place, du point de vue javascript, pas de html/css ici :
  </p>

  <ul>
    <li>La classe Chrono en VanillaJS,</li>
    <li>Le life cycle avec React-Redux,</li>
  </ul>

  <h2>La classe Chrono en VanillaJS</h2>
  <p>
    La classe chrono ci-dessous procure ses mÃ©thodes de contrÃ´le et nÃ©cessite un
    Ã©lÃ©ment du DOM pour son instanciation (le temps du chrono sâ€™affichera
    dedans) :
  </p>
  <pre>
    <code>
      
      /**
      * Object Chrono,
      * ATTRIBUTS D'INSTANCE :
      *  - startTime = integer, le temps de dÃ©part (0 par dÃ©faut)
      *  - display = HTMLElement dans lequel afficher,
      *  - interval = reprÃ©sente setInterval en cours.
      *
      * FONCTIONS :
      * - countAhead : Compte de 0 jusqu'Ã  l'info de stopper, +1 Ã  chaque seconde
      * - countDown : Compte Ã  rebours depuis un temps donner jusqu'Ã  0,
      *    - return void
      * - stop : ArrÃªte countAhead et countDown,
      *    - return this.startTime
      * - timeDislay : mÃ©thode interne
      *    - return string
      * - playFirstBip : envoi les premiers Bips
      * - playFinalBip : envoi le Bip final
      */
      class Chrono {
        constructor(startTime, display) {
          this.startTime = startTime;
          this.display = display;
          this.interval = 0;
          this.nextCountDown = false;
          console.log(&amp;nouvel objet Chrono crÃ©Ã©&amp;);
        }
      
        countAhead() {
          console.log(&amp;dÃ©part chrono sur = &amp; + this.display);
      
          const aRepeter = () => {
            // On affiche le temps
            this.display.innerText = this.startTime;
            this.startTime += 1;
          };
          this.interval = setInterval(aRepeter, 1000);
        }
      
        countDown() {
          console.log(&amp;dÃ©part compte Ã  rebours&amp;);
          let timeString = this.timeDisplay();
          // this.display.innerText = timeString;
      
          const aRepeter = () => {
            if (this.startTime <= 0) {
              clearInterval(this.interval);
            } else {
              this.startTime--;
              timeString = this.timeDisplay();
              this.display.innerText = timeString;
      
              if (this.startTime > 0 && this.startTime < 3) {
                this.playFirstBip();
              }
              if (this.startTime == 0) this.playFinalBip();
            }
          };
          aRepeter();
          this.interval = setInterval(aRepeter, 1000);
        }
      
        stop() {
          console.log(&amp;ArrÃªt du chrono&amp;);
          clearInterval(this.interval);
          this.interval = 0;
          let timeString = this.timeDisplay();
          this.display.innerText = timeString;
          return this.startTime;
        }
      
        timeDisplay() {
          let unitMin = Math.floor((this.startTime / 60) % 10);
          let tenMin = Math.floor(this.startTime / 600);
      
          let unitSec = Math.floor((this.startTime % 60) % 10);
          let tenSec = Math.floor((this.startTime % 60) / 10);
      
          let string = tenMin + &amp;&amp; + unitMin + &amp;:&amp; + tenSec + &amp;&amp; + unitSec;
          return string;
        }
      
        playFirstBip() {
          console.log(&amp;on fait Bip !&amp;);
      
          let firstBip = new Audio(&amp;./public/sounds/first_bips.wav&amp;);
          firstBip.play();
        }
      
        playFinalBip() {
          console.log(&amp;on fait le bip final !&amp;);
      
          let finalBip = new Audio(&amp;./public/sounds/final_bip.wav&amp;);
          finalBip.play();
        }
      }
    </code>
  </pre>

  <p>
    Alors Ã§a fonctionne bien, Ã§a pourrait probablement Ãªtre adaptÃ© Ã  un
    composant React sous forme de classe avec son propre state. Cependant, jâ€™ai
    choisi dâ€™utiliser React+Redux et le life-cycle me permet dâ€™obtenir les mÃªmes
    effets mais avec une logique Ã©clatÃ©e.
  </p>

  <h2>Le life cycle avec React-Redux</h2>
  <p>Le composant Chrono, difficile de faire plus simple :</p>

  <pre>
    <code>
    const Chrono = ({time, text, isCounting, setTime}) => {
    
      useEffect(() => {
    
        if (isCounting){
            setTimeout(() => {setTime(time + .1)}, 100 )
          }
      }, [time, isCounting, setTime])
    
      return(
        &lt;div className=&amp;readtraining__timedisplay&amp;&gt;
          {text !== &amp;&amp; && &lt;div className=&amp;readtraining__timedisplay__text&amp;&gt;
            {text}
            &lt;/div&gt;}
      
          &lt;div className=&amp;readtraining__timedisplay__time&amp;&gt;
            {trainingServices.formatChrono(time)}
          &lt;/div&gt;
        &lt;/div&gt;
    )}
    
    export default Chrono;
  </code>
</pre>
  <p>
    Donc le principe, aprÃ¨s le render du composant â€˜Chronoâ€™ useEffect()
    dÃ©clenche la mise Ã  jour de la prop â€˜timeâ€™ dans le store aprÃ¨s 0.1s.
  </p>

  <p>
    La mise Ã  jour de la prop â€˜timeâ€™ provoque un nouveau render via le reducer
    puis le store, en ainsi de suite tant que la prop â€˜isCountingâ€™ vaut â€˜trueâ€™.
  </p>

  <p>Extrait du reducer :</p>

  <pre>
      <code>
    ...
        case SET_EXOPLAYING_TIME:
          return {
            ...state,
            exoPlaying: {
              ...state.exoPlaying,
              currentTime: action.time,
            }
          }
    ...
  </code>
</pre>
  <p>
    La mise en pause et la reprise du chrono sont effectuÃ©es grÃ¢ce Ã  des actions
    dispatchÃ©es dans le store via des boutons de contrÃ´les dans lâ€™UI.
  </p>

  <p>Par exemple le bonton â€˜Playâ€™ du chrono :</p>
  <pre>
    <code>
    &lt;button
      className=&amp;training__button --transparent --xxl&amp;
      onClick={() =&gt; startChrono()}
    &gt;
      &lt;i className=&amp;fas fa-play&amp;&gt;&lt;/i&gt;
    &lt;/button&gt;
  </code>
</pre>
  <p>Dispatch lâ€™action dans le reducer :</p>

  <pre>
    <code>
        case START_CHRONO:
          return {
            ...state,
            exoPlaying: {
              ...state.exoPlaying,
              isCounting: true,
            },
            globalTime: {
              ...state.globalTime,
              isCounting: true,
            },
          }
        </code>
      </pre>
  <p>
    On voit ici que lâ€™action â€˜START_CHRONOâ€™ dÃ©clenchera au final la mise en
    route de deux Chrono diffÃ©rents, celui de lâ€™exercice en cours et celui
    gÃ©nÃ©ral pour lâ€™ensemble des exercices enchainÃ©s.
  </p>

  <p>
    Ce qui amÃ¨ne Ã  la problÃ©matique de lâ€™enchainement complexe de comptes Ã 
    rebours.
  </p>

  <p>
    Lâ€™utilisation de â€˜setTimeoutâ€™ câ€™est super pratiqueâ€¦ oui mais voilÃ , pour
    certains entrainements il me faut enchainer des comptes Ã  rebours et avoir
    un compte Ã  rebours gÃ©nÃ©ral.
  </p>

  <p>
    La fin dâ€™un compte Ã  rebours dâ€™exercice ou le changement dâ€™exercice provoquÃ©
    par lâ€™utilisateur doit mettre Ã  jour le compte Ã  rebours gÃ©nÃ©ral.
  </p>

  <p>
    Or, chaque mise Ã  jour de la prop affichÃ©e par le compte Ã  rebours gÃ©nÃ©ral,
    que ce soit par le composant compte Ã  rebours lui-mÃªme ou par le changement
    dâ€™exercice, dÃ©clenche un â€˜setTimeout()â€™â€¦ câ€™est le bordel.
  </p>

  <p>
    Une solution simple, câ€™est de rajouter une prop dans le state pour indiquer
    au composant â€˜GlobalCountDownâ€™ de ne pas envoyer dâ€™action (donc pas de
    setTimeout()) pour modifier sa prop â€˜timeâ€™ quand elle vient dâ€™Ãªtre modifiÃ©e
    par un changement dâ€™exercice.
  </p>

  <h3>Le â€˜GlobalCountDownâ€™ :</h3>
  <pre>
    <code>
    const GlobalCountDown = ({time, text, isCounting, setTime, resetCurrent, setResetCurrent}) => {
    
      useEffect(() => {
    
        if (isCounting){
          if (resetCurrent) {
            // ExoPlaying changes
            setTimeout(() => {
              setResetCurrent(false);
            }, 100 );
            return
          }
          if (time > 0.1) {
            setTimeout(() => {setTime(time - .1)}, 100 );
            return
          }
          //
          setTime(0)
        }
      }, [time, isCounting, setTime, resetCurrent, setResetCurrent])
    </code>
  </pre>
  <p>La mise Ã  jour de la prop dans le reducer au changement dâ€™exercice :</p>
  <pre>
    <code>
      case SET_CURRENT_EXO:
        if (state.timeline[exoIndex].beginning) exoIndex++;
        if (exoIndex === state.timeline.length - 1) return state;
      
        return {
            ...state,
          exoPlaying: {
            ...state.exoPlaying,
            currentTime: state.timeline[exoIndex].duration,
          },
          globalTime: {
            ...state.globalTime,
            resetCurrent: true,
            currentTime: trainingServices.getRemainingDuration(state.timeline, exoIndex),
          }
        }
      </code>
    </pre>
  <p>
    Finalement, je suis parti sur une solution un peu plus stylÃ©e Ã  base de
    promise et async/await ðŸ™‚
  </p>

  <h2>Bonus async/await</h2>
  <p>
    Le petit problÃ¨me avec le setTimeout, quand il a une callback qui gÃ¨re de la
    donnÃ©e, câ€™est que la valeur de cette donnÃ©e est fixÃ©e au moment de
    lâ€™exÃ©cution du setTimeout, pas au moment de lâ€™exÃ©cution de sa callback. Donc
    si la valeur de la donnÃ©e a changer entre temps, câ€™est la galÃ¨re.
  </p>

  <p>
    Lâ€™utilisation dâ€™une fonction asynchrone me permet dâ€™attendre le temps prÃ©vu
    puis ensuite de comparer mes donnÃ©es Ã  leur valeur actuelle, câ€™est quand
    mÃªme plus propre dans la logique.
  </p>

  <p>Pour mettre en place le principe, il faut :</p>

  <ul>
    <li>Une fonction qui renvoit une Promise,</li>
    <li>
      Une fonction asynchrone qui attend que la Promise se rÃ©solve avant de
      passer Ã  la suite,
    </li>
  </ul>
  <p>La fonction avec Promise :</p>

  <pre>
    <code>
    wait100ms = () => new Promise((resolve) => {
      setTimeout(() => resolve(), 100);
    }
  </code>
</pre>
  <p>
    La fonction asynchrone (auto-executable) dans le useEffect de mon Chrono :
  </p>
  <pre>
    <code>
    const Chrono = ({ time, isCounting, setChronoTime }) => {
      useEffect(() => {
    
        (async() => {
    
          await wait100ms();
    
          if (isCounting ){
            setChronoTime(time + .1)
          }
        })()
    
      }, [time, isCounting, setChronoTime])
    </code>
  </pre>
  <p>Fini pour aujourdâ€™hui ðŸ™‚</p>
</article>
